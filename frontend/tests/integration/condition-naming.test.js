/**
 * Condition Naming Tests
 * 
 * Tests based on test-scenarios-condition-names.csv
 * Verifies automatic naming behavior for conditions, groups, and expressions
 */

import { describe, it, expect } from 'vitest';
import {
  isAutoGeneratedName,
  extractNumber,
  getNextNumber,
  generateDefaultName,
  updateNameOnTypeChange,
  generateResultName,
  generateElseName,
  assignNamesToTree
} from '../../src/components/RuleBuilder/utils/conditionNaming';

describe('Condition Naming - Utility Functions', () => {
  describe('isAutoGeneratedName', () => {
    it('recognizes root level auto-generated names', () => {
      expect(isAutoGeneratedName('Condition', 'condition', '')).toBe(true);
      expect(isAutoGeneratedName('Condition Group', 'conditionGroup', '')).toBe(true);
    });

    it('recognizes numbered auto-generated names', () => {
      expect(isAutoGeneratedName('Condition 1', 'condition', '')).toBe(true);
      expect(isAutoGeneratedName('Condition Group 2', 'conditionGroup', '')).toBe(true);
      expect(isAutoGeneratedName('Condition 1.2', 'condition', '1')).toBe(true);
      expect(isAutoGeneratedName('Condition Group 2.1.3', 'conditionGroup', '2.1')).toBe(true);
    });

    it('recognizes rule IDs as auto-generated for ruleRef type', () => {
      expect(isAutoGeneratedName('MY_RULE_ID', 'ruleRef', '')).toBe(true);
      expect(isAutoGeneratedName('SAVE', 'ruleRef', '')).toBe(true);
    });

    it('recognizes custom names', () => {
      expect(isAutoGeneratedName('User Named 1', 'condition', '')).toBe(false);
      expect(isAutoGeneratedName('My Custom Condition', 'conditionGroup', '')).toBe(false);
    });
  });

  describe('extractNumber', () => {
    it('extracts numbers from condition names', () => {
      expect(extractNumber('Condition 1')).toBe('1');
      expect(extractNumber('Condition 2.3')).toBe('2.3');
      expect(extractNumber('Condition Group 1.2.4')).toBe('1.2.4');
    });

    it('returns null for names without numbers', () => {
      expect(extractNumber('Condition')).toBe(null);
      expect(extractNumber('User Named 1')).toBe(null);
    });
  });

  describe('getNextNumber', () => {
    it('returns 1 for empty siblings array', () => {
      expect(getNextNumber([], '')).toBe(1);
    });

    it('calculates next number at root level', () => {
      const siblings = [
        { name: 'Condition 1' },
        { name: 'Condition Group 2' },
        { name: 'Condition 3' }
      ];
      expect(getNextNumber(siblings, '')).toBe(4);
    });

    it('calculates next number at nested level', () => {
      const siblings = [
        { name: 'Condition 1.1' },
        { name: 'Condition Group 1.2' }
      ];
      expect(getNextNumber(siblings, '1')).toBe(3);
    });

    it('handles gaps in numbering', () => {
      const siblings = [
        { name: 'Condition 1' },
        { name: 'Condition 5' }
      ];
      expect(getNextNumber(siblings, '')).toBe(6);
    });
  });

  describe('generateDefaultName', () => {
    it('generates root level names', () => {
      expect(generateDefaultName('condition', '', null)).toBe('Condition');
      expect(generateDefaultName('conditionGroup', '', null)).toBe('Condition Group');
    });

    it('generates numbered names at level 1', () => {
      expect(generateDefaultName('condition', '', 1)).toBe('Condition 1');
      expect(generateDefaultName('conditionGroup', '', 2)).toBe('Condition Group 2');
    });

    it('generates nested names', () => {
      expect(generateDefaultName('condition', '1', 2)).toBe('Condition 1.2');
      expect(generateDefaultName('conditionGroup', '2.1', 3)).toBe('Condition Group 2.1.3');
    });
  });

  describe('updateNameOnTypeChange', () => {
    it('preserves number when switching between condition and group', () => {
      expect(updateNameOnTypeChange('Condition 1', 'condition', 'conditionGroup', '', 1))
        .toBe('Condition Group 1');
      expect(updateNameOnTypeChange('Condition Group 2', 'conditionGroup', 'condition', '', 2))
        .toBe('Condition 2');
    });

    it('preserves custom names across type changes', () => {
      expect(updateNameOnTypeChange('User Named 1', 'condition', 'conditionGroup', '', 1))
        .toBe('User Named 1');
      expect(updateNameOnTypeChange('User Named 1', 'conditionGroup', 'condition', '', 1))
        .toBe('User Named 1');
    });

    it('uses rule ID when switching to ruleRef with rule selected', () => {
      expect(updateNameOnTypeChange('Condition 1', 'condition', 'ruleRef', '', 1, 'MY_RULE'))
        .toBe('MY_RULE');
      expect(updateNameOnTypeChange('User Named 1', 'condition', 'ruleRef', '', 1, 'SAVE'))
        .toBe('SAVE');
    });

    it('generates auto name when switching from ruleRef', () => {
      expect(updateNameOnTypeChange('MY_RULE', 'ruleRef', 'condition', '', 1))
        .toBe('Condition 1');
      expect(updateNameOnTypeChange('SAVE', 'ruleRef', 'conditionGroup', '', 2))
        .toBe('Condition Group 2');
    });
  });

  describe('generateResultName', () => {
    it('generates result names for THEN clauses', () => {
      expect(generateResultName(0)).toBe('Result 1');
      expect(generateResultName(1)).toBe('Result 2');
      expect(generateResultName(5)).toBe('Result 6');
    });
  });

  describe('generateElseName', () => {
    it('always returns "Default"', () => {
      expect(generateElseName()).toBe('Default');
    });
  });

  describe('assignNamesToTree', () => {
    it('assigns names to flat condition tree', () => {
      const tree = {
        type: 'conditionGroup',
        name: 'Condition Group',
        conditions: [
          { type: 'condition', name: 'Condition 1' },
          { type: 'condition', name: 'Condition 2' }
        ]
      };

      // Call with position=null for root level
      const result = assignNamesToTree(tree, '', null);
      expect(result.name).toBe('Condition Group');
      expect(result.conditions[0].name).toBe('Condition 1');
      expect(result.conditions[1].name).toBe('Condition 2');
    });

    it('assigns names to nested condition tree', () => {
      const tree = {
        type: 'conditionGroup',
        name: 'Condition Group',
        conditions: [
          {
            type: 'conditionGroup',
            name: 'Condition Group 1',
            conditions: [
              { type: 'condition', name: 'Condition 1.1' },
              { type: 'condition', name: 'Condition 1.2' }
            ]
          },
          { type: 'condition', name: 'Condition 2' }
        ]
      };

      const result = assignNamesToTree(tree, '', null);
      expect(result.conditions[0].name).toBe('Condition Group 1');
      expect(result.conditions[0].conditions[0].name).toBe('Condition 1.1');
      expect(result.conditions[0].conditions[1].name).toBe('Condition 1.2');
      expect(result.conditions[1].name).toBe('Condition 2');
    });

    it('preserves custom names in tree', () => {
      const tree = {
        type: 'conditionGroup',
        name: 'Condition Group',
        conditions: [
          { type: 'condition', name: 'User Named 1' },
          { type: 'condition', name: 'Condition 2' }
        ]
      };

      const result = assignNamesToTree(tree, '', null);
      expect(result.conditions[0].name).toBe('User Named 1');
      expect(result.conditions[1].name).toBe('Condition 2');
    });
  });
});

describe('Condition Naming - Simple Condition Scenarios', () => {
  it('Scenario: New Simple Condition - Initial State', () => {
    // Create new rule with structure = "condition"
    const condition = {
      type: 'condition',
      name: generateDefaultName('condition', '', null)
    };

    expect(condition.name).toBe('Condition');
  });

  it('Scenario: Convert to Group', () => {
    // Start: "Condition"
    let name = 'Condition';
    
    // Change source to Group â†’ "Condition Group" with children "Condition 1", "Condition 2"
    name = updateNameOnTypeChange(name, 'condition', 'conditionGroup', '', null);
    expect(name).toBe('Condition Group');

    const child1 = generateDefaultName('condition', '', 1);
    const child2 = generateDefaultName('condition', '', 2);
    expect(child1).toBe('Condition 1');
    expect(child2).toBe('Condition 2');
  });

  it('Scenario: Convert to Rule Reference', () => {
    let name = 'Condition';
    
    // Change source to Rule (before selection)
    name = updateNameOnTypeChange(name, 'condition', 'ruleRef', '', null);
    expect(name).toBe('Condition');

    // Select Rule
    name = updateNameOnTypeChange(name, 'ruleRef', 'ruleRef', '', null, 'MY_RULE_ID');
    expect(name).toBe('MY_RULE_ID');

    // Change source back to Condition
    name = updateNameOnTypeChange(name, 'ruleRef', 'condition', '', null);
    expect(name).toBe('Condition');
  });

  it('Scenario: Add Condition and Convert Children', () => {
    // Add Condition creates group
    const siblings = [];
    const nextNum = getNextNumber(siblings, '');
    expect(nextNum).toBe(1);

    // Condition 1 converts to group
    let cond1Name = 'Condition 1';
    cond1Name = updateNameOnTypeChange(cond1Name, 'condition', 'conditionGroup', '', 1);
    expect(cond1Name).toBe('Condition Group 1');

    // Children under Condition Group 1
    const child1_1 = generateDefaultName('condition', '1', 1);
    const child1_2 = generateDefaultName('condition', '1', 2);
    expect(child1_1).toBe('Condition 1.1');
    expect(child1_2).toBe('Condition 1.2');

    // Condition 2 converts to group
    let cond2Name = 'Condition 2';
    cond2Name = updateNameOnTypeChange(cond2Name, 'condition', 'conditionGroup', '', 2);
    expect(cond2Name).toBe('Condition Group 2');
  });

  it('Scenario: Deep Nesting', () => {
    // Condition 2.1 converts to group
    let name = 'Condition 2.1';
    name = updateNameOnTypeChange(name, 'condition', 'conditionGroup', '2', 1);
    expect(name).toBe('Condition Group 2.1');

    // Children under Condition Group 2.1
    const child1 = generateDefaultName('condition', '2.1', 1);
    const child2 = generateDefaultName('condition', '2.1', 2);
    expect(child1).toBe('Condition 2.1.1');
    expect(child2).toBe('Condition 2.1.2');
  });

  it('Scenario: User Renaming', () => {
    // Change Condition 1 name to "User Named 1"
    let name = 'User Named 1';

    // Convert to Group - should preserve custom name
    name = updateNameOnTypeChange(name, 'condition', 'conditionGroup', '', 1);
    expect(name).toBe('User Named 1');

    // Children still use numeric naming (1.1, 1.2)
    const child1 = generateDefaultName('condition', '1', 1);
    const child2 = generateDefaultName('condition', '1', 2);
    expect(child1).toBe('Condition 1.1');
    expect(child2).toBe('Condition 1.2');

    // Convert back to Condition - preserve custom name
    name = updateNameOnTypeChange(name, 'conditionGroup', 'condition', '', 1);
    expect(name).toBe('User Named 1');

    // Convert back to Group again - still preserve
    name = updateNameOnTypeChange(name, 'condition', 'conditionGroup', '', 1);
    expect(name).toBe('User Named 1');
  });

  it('Scenario: Rule Reference Replaces Custom Name', () => {
    let name = 'Condition 1';

    // Convert to Rule and select rule - should use rule ID
    name = updateNameOnTypeChange(name, 'condition', 'ruleRef', '', 1, 'SAVE');
    expect(name).toBe('SAVE');

    // Convert back to Condition - reverts to auto-generated (custom name lost)
    name = updateNameOnTypeChange(name, 'ruleRef', 'condition', '', 1);
    expect(name).toBe('Condition 1');
  });
});

describe('Condition Naming - Case Expression Scenarios', () => {
  it('Scenario: New Case Expression - Initial State', () => {
    // Create new rule and change structure to "case"
    const whenConditionName = generateDefaultName('condition', '', 1);
    const thenResultName = generateResultName(0);
    const elseName = generateElseName();

    expect(whenConditionName).toBe('Condition 1');
    expect(thenResultName).toBe('Result 1');
    expect(elseName).toBe('Default');
  });

  it('Scenario: WHEN Condition Conversions', () => {
    let condName = 'Condition 1';

    // Change Condition 1 source to Group
    condName = updateNameOnTypeChange(condName, 'condition', 'conditionGroup', '', 1);
    expect(condName).toBe('Condition Group 1');

    const child1 = generateDefaultName('condition', '1', 1);
    const child2 = generateDefaultName('condition', '1', 2);
    expect(child1).toBe('Condition 1.1');
    expect(child2).toBe('Condition 1.2');

    // Change source to Rule (without selecting a rule yet)
    condName = updateNameOnTypeChange(condName, 'conditionGroup', 'ruleRef', '', 1);
    expect(condName).toBe('Condition Group 1'); // Preserves name until rule selected

    condName = updateNameOnTypeChange(condName, 'ruleRef', 'ruleRef', '', 1, 'MY_RULE');
    expect(condName).toBe('MY_RULE');

    // Change source back to Condition
    condName = updateNameOnTypeChange(condName, 'ruleRef', 'condition', '', 1);
    expect(condName).toBe('Condition 1');
  });

  it('Scenario: THEN Expression with Rule Reference', () => {
    let resultName = 'Result 1';

    // Expression source changes don't affect naming for non-ruleRef
    expect(resultName).toBe('Result 1');

    // When expression source becomes Rule (placeholder before selection)
    expect(resultName).toBe('Result 1');

    // When rule selected, name becomes rule ID
    resultName = 'MY_RULE_ID';
    expect(resultName).toBe('MY_RULE_ID');

    // Change back to Value - revert to auto-generated
    resultName = generateResultName(0);
    expect(resultName).toBe('Result 1');
  });

  it('Scenario: Multiple WHEN Clauses', () => {
    // First WHEN clause
    const when1 = generateDefaultName('condition', '', 1);
    const result1 = generateResultName(0);

    expect(when1).toBe('Condition 1');
    expect(result1).toBe('Result 1');

    // Add second WHEN clause
    const when2 = generateDefaultName('condition', '', 2);
    const result2 = generateResultName(1);

    expect(when2).toBe('Condition 2');
    expect(result2).toBe('Result 2');

    // ELSE always "Default"
    expect(generateElseName()).toBe('Default');
  });

  it('Scenario: User Renamed Result with Rule Reference', () => {
    // User renames Result 2
    let resultName = 'User Named Result 2';

    // Change expression source to Rule - preserve custom name initially
    expect(resultName).toBe('User Named Result 2');

    // Select Rule - replace with rule ID
    resultName = 'MY_RULE_ID';
    expect(resultName).toBe('MY_RULE_ID');

    // Change expression source to Field - revert to auto-generated (custom lost)
    resultName = generateResultName(1);
    expect(resultName).toBe('Result 2');
  });

  it('Scenario: Nested Groups in WHEN Clause', () => {
    // Add Condition to WHEN 1
    let cond1 = 'Condition 1';
    cond1 = updateNameOnTypeChange(cond1, 'condition', 'conditionGroup', '', 1);
    expect(cond1).toBe('Condition Group 1');

    // Children
    const child1_1 = generateDefaultName('condition', '1', 1);
    const child1_2 = generateDefaultName('condition', '1', 2);
    expect(child1_1).toBe('Condition 1.1');
    expect(child1_2).toBe('Condition 1.2');

    // Convert Condition 1.1 to Group
    let cond1_1 = child1_1;
    cond1_1 = updateNameOnTypeChange(cond1_1, 'condition', 'conditionGroup', '1', 1);
    expect(cond1_1).toBe('Condition Group 1.1');

    // Grand-children
    const child1_1_1 = generateDefaultName('condition', '1.1', 1);
    const child1_1_2 = generateDefaultName('condition', '1.1', 2);
    expect(child1_1_1).toBe('Condition 1.1.1');
    expect(child1_1_2).toBe('Condition 1.1.2');

    // Add Group to WHEN clause root
    const siblings = [
      { name: 'Condition Group 1' },
      { name: 'Condition Group 2' }
    ];
    const nextNum = getNextNumber(siblings, '');
    expect(nextNum).toBe(3);

    const newGroup = generateDefaultName('conditionGroup', '', nextNum);
    expect(newGroup).toBe('Condition Group 3');
  });
});
