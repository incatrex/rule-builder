/**
 * Condition Naming Utilities
 * 
 * Handles automatic naming for conditions, condition groups, and expressions.
 * 
 * Naming Rules:
 * 1. Level 0 (root): No number - "Condition", "Condition Group", or rule ID
 * 2. Level 1+: Sequential numbering - "Condition 1", "Condition Group 2", etc.
 * 3. Number preservation: Type changes keep the number, change prefix
 * 4. Dot notation: Children inherit parent's number - "1.1", "1.2", "2.1.1", etc.
 * 5. Custom names: Preserved across type changes (Condition ↔ ConditionGroup)
 * 6. Rule references: Use rule ID, discard any previous custom name
 * 7. Switching from RuleRef: Revert to auto-generated name (custom names not restored)
 */

/**
 * Checks if a name is auto-generated (matches default pattern)
 * @param {string} name - Name to check
 * @param {string} type - Type: 'condition', 'conditionGroup', 'ruleRef'
 * @param {string} parentNumber - Parent's number prefix (e.g., "1", "1.2")
 * @returns {boolean} - True if name matches auto-generated pattern
 */
export function isAutoGeneratedName(name, type, parentNumber = '') {
  if (!name) return true;
  
  const number = parentNumber ? `${parentNumber}.\\d+` : '\\d+';
  
  const patterns = {
    condition: [
      new RegExp(`^Condition ${number}$`),
      /^Condition$/  // Root level
    ],
    conditionGroup: [
      new RegExp(`^Condition Group ${number}$`),
      /^Condition Group$/  // Root level
    ],
    ruleRef: [
      new RegExp(`^Condition ${number}$`),
      /^Condition$/,  // Root level before rule selected
      /^[A-Z0-9_]+$/  // Rule ID format
    ]
  };
  
  const typePatterns = patterns[type] || [];
  return typePatterns.some(pattern => pattern.test(name));
}

/**
 * Extracts the numeric portion from a name (e.g., "Condition 1.2" → "1.2")
 * @param {string} name - Name to parse
 * @returns {string|null} - Extracted number or null if not found
 */
export function extractNumber(name) {
  if (!name) return null;
  
  // Match patterns like "Condition 1", "Condition Group 2.1", etc.
  const match = name.match(/(?:Condition|Condition Group)\s+([\d.]+)$/);
  return match ? match[1] : null;
}

/**
 * Gets the next available number at a given level
 * @param {Array} siblings - Array of sibling conditions/groups at same level
 * @param {string} parentNumber - Parent's number (empty for root)
 * @returns {number} - Next sequential number
 */
export function getNextNumber(siblings, parentNumber = '') {
  if (!siblings || siblings.length === 0) return 1;
  
  const numbers = siblings
    .map(sibling => {
      const num = extractNumber(sibling.name);
      if (!num) return 0;
      
      // For nested items, extract just the last segment
      // e.g., "1.2" → 2, "3" → 3
      const segments = num.split('.');
      const expectedDepth = parentNumber ? parentNumber.split('.').length + 1 : 1;
      
      if (segments.length === expectedDepth) {
        return parseInt(segments[segments.length - 1], 10);
      }
      return 0;
    })
    .filter(n => n > 0);
  
  return numbers.length > 0 ? Math.max(...numbers) + 1 : 1;
}

/**
 * Generates a default name based on type and position
 * @param {string} type - 'condition', 'conditionGroup', 'ruleRef' (before rule selected)
 * @param {string} parentNumber - Parent's number (empty string for root level)
 * @param {number} position - Position at current level (1-based)
 * @returns {string} - Generated name
 */
export function generateDefaultName(type, parentNumber = '', position = null) {
  // Root level (no parent number)
  if (!parentNumber && position === null) {
    return type === 'conditionGroup' ? 'Condition Group' : 'Condition';
  }
  
  // Calculate full number
  const fullNumber = parentNumber ? `${parentNumber}.${position}` : `${position}`;
  
  // Generate name based on type
  const prefix = type === 'conditionGroup' ? 'Condition Group' : 'Condition';
  return `${prefix} ${fullNumber}`;
}

/**
 * Updates a name when type changes, preserving custom names
 * @param {string} currentName - Current name
 * @param {string} oldType - Previous type
 * @param {string} newType - New type
 * @param {string} parentNumber - Parent's number prefix
 * @param {number} position - Position at current level
 * @param {string} ruleId - Rule ID (only for ruleRef type)
 * @returns {string} - Updated name
 */
export function updateNameOnTypeChange(currentName, oldType, newType, parentNumber = '', position = null, ruleId = null) {
  // When switching to ruleRef with a rule selected, use rule ID
  if (newType === 'ruleRef' && ruleId) {
    return ruleId;
  }
  
  // When switching to ruleRef without a rule (placeholder state), preserve current name
  if (newType === 'ruleRef' && !ruleId) {
    return currentName;
  }
  
  // When switching from ruleRef to condition/group, generate new auto name
  if (oldType === 'ruleRef' && (newType === 'condition' || newType === 'conditionGroup')) {
    return generateDefaultName(newType, parentNumber, position);
  }
  
  // Check if current name is auto-generated
  const isAuto = isAutoGeneratedName(currentName, oldType, parentNumber);
  
  if (isAuto) {
    // Update prefix but keep number
    const number = extractNumber(currentName);
    if (number) {
      const prefix = newType === 'conditionGroup' ? 'Condition Group' : 'Condition';
      return `${prefix} ${number}`;
    }
    // Root level
    return generateDefaultName(newType, parentNumber, position);
  }
  
  // Custom name - preserve it across Condition ↔ ConditionGroup changes
  return currentName;
}

/**
 * Generates default name for a THEN clause result
 * @param {number} whenClauseIndex - Index of the WHEN clause (0-based)
 * @returns {string} - Result name (e.g., "Result 1")
 */
export function generateResultName(whenClauseIndex) {
  return `Result ${whenClauseIndex + 1}`;
}

/**
 * Generates default name for ELSE clause
 * @returns {string} - Always "Default"
 */
export function generateElseName() {
  return 'Default';
}

/**
 * Assigns proper names to all conditions in a tree structure
 * Recursively processes nested conditions and groups
 * @param {Object|Array} node - Condition, ConditionGroup, or array of conditions
 * @param {string} parentNumber - Parent's number prefix (empty for root)
 * @param {number} position - Position at current level (null for root)
 * @returns {Object|Array} - Node with updated names
 */
export function assignNamesToTree(node, parentNumber = '', position = null) {
  if (!node) return node;
  
  // Handle array of siblings
  if (Array.isArray(node)) {
    return node.map((child, index) => {
      const childPosition = index + 1;
      return assignNamesToTree(child, parentNumber, childPosition);
    });
  }
  
  // Handle single condition or group
  const { type, name, conditions } = node;
  
  // Determine if name is auto-generated
  const isAuto = isAutoGeneratedName(name, type, parentNumber);
  
  // Generate new name if auto-generated
  let newName = name;
  if (isAuto) {
    newName = generateDefaultName(type, parentNumber, position);
  }
  
  // Process children if it's a conditionGroup
  let updatedConditions = conditions;
  if (type === 'conditionGroup' && conditions && conditions.length > 0) {
    // Calculate child parent number based on current position
    let childParentNumber;
    if (position === null) {
      // Root level - children start with no prefix
      childParentNumber = '';
    } else if (parentNumber) {
      // Nested - append position to parent number
      childParentNumber = `${parentNumber}.${position}`;
    } else {
      // First level - use position as prefix
      childParentNumber = `${position}`;
    }
    
    updatedConditions = conditions.map((child, index) => 
      assignNamesToTree(child, childParentNumber, index + 1)
    );
  }
  
  return {
    ...node,
    name: newName,
    ...(updatedConditions && { conditions: updatedConditions })
  };
}

/**
 * Gets all sibling conditions at the same level for calculating next number
 * @param {Object} rootCondition - Root condition/group structure
 * @param {string} parentPath - Path to parent (empty for root level)
 * @returns {Array} - Array of sibling conditions
 */
export function getSiblingsAtLevel(rootCondition, parentPath = '') {
  if (!parentPath) {
    // Root level - return array with just root condition
    return [rootCondition];
  }
  
  // Navigate to parent and return its children
  const pathSegments = parentPath.split('.');
  let current = rootCondition;
  
  for (const segment of pathSegments) {
    if (current.type !== 'conditionGroup' || !current.conditions) {
      return [];
    }
    
    const index = parseInt(segment, 10) - 1;
    current = current.conditions[index];
    
    if (!current) return [];
  }
  
  return current.type === 'conditionGroup' && current.conditions ? current.conditions : [];
}
