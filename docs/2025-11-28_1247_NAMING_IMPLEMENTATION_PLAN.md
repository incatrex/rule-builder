# Condition Naming Implementation Plan

## Current Status

### ‚úÖ Completed
1. **Naming Utility Module** (`/frontend/src/utils/conditionNaming.js`)
   - All core functions implemented and tested
   - 35 comprehensive tests covering all CSV scenarios
   - Functions: `generateDefaultName`, `updateNameOnTypeChange`, `getNextNumber`, `extractNumber`, `isAutoGeneratedName`, `assignNamesToTree`, `generateResultName`, `generateElseName`

2. **Condition.jsx - Partial Integration**
   - Added imports for naming utilities
   - Added props: `parentNumber`, `position`, `siblings`
   - Updated `handleSourceChange()` to use naming logic
   - Updated `handleRuleRefChange()` to set name to rule ID when rule selected

3. **Bug Fix - RuleReference**
   - Fixed config propagation to RuleSelector components
   - RuleReference now properly passes config to both RuleSelector instances

4. **All Tests Passing**
   - 97 backend tests ‚úì
   - 100 frontend tests ‚úì (including 35 new naming tests)

---

## Architecture Issues & Cleanup Recommendations

### üî¥ Critical Issues Found

#### 1. **Props Explosion Problem**
**Current Approach**: Adding `parentNumber`, `position`, `siblings` to every Condition/ConditionGroup
- Creates tight coupling between parent and child
- Makes components harder to test in isolation
- Requires threading props through multiple levels
- Changes to naming logic require updates in many places

**Recommended Solution**: **Context-based Naming Service**
```javascript
// Create NamingContext to provide naming services
const NamingContext = React.createContext({
  getNameForNewCondition: () => {},
  getNameForNewGroup: () => {},
  updateNameOnTypeChange: () => {},
  // etc.
});

// Use in components:
const { getNameForNewCondition } = useContext(NamingContext);
```

**Benefits**:
- Centralized naming logic
- No prop drilling
- Easier testing (mock context)
- Single source of truth for naming

#### 2. **Inconsistent Expression Creation**
**Problem**: Multiple places create expressions with different patterns:
- `createDirectExpression()` in Expression.jsx
- Inline object creation in Condition.jsx, ConditionGroup.jsx, Case.jsx
- Different default operators in different places

**Found Examples**:
```javascript
// In Condition.jsx (line ~198)
left: createDirectExpression('field', 'number', 'TABLE1.NUMBER_FIELD_01')

// In ConditionGroup.jsx (line ~301)
left: { 
  type: 'expressionGroup',
  returnType: 'number',
  expressions: [{ type: 'field', returnType: 'number', field: null }],
  operators: []
}
```

**Recommended Solution**: **Centralized Factory Functions**
```javascript
// /utils/structureFactories.js
export function createDefaultCondition(config, name) {
  const defaultType = 'number';
  const defaultOperator = config?.types?.[defaultType]?.defaultConditionOperator || 'equal';
  
  return {
    type: 'condition',
    returnType: 'boolean',
    name,
    left: createDirectExpression('field', defaultType, config?.defaultField || null),
    operator: defaultOperator,
    right: createDirectExpression('value', defaultType, 0)
  };
}

export function createDefaultConditionGroup(config, name, children = []) {
  return {
    type: 'conditionGroup',
    returnType: 'boolean',
    name,
    conjunction: 'AND',
    not: false,
    conditions: children.length > 0 ? children : [
      createDefaultCondition(config, 'Condition 1'),
      createDefaultCondition(config, 'Condition 2')
    ]
  };
}
```

#### 3. **State Management Complexity**
**Problem**: Each component manages its own state separately:
- Condition.jsx: `useState(conditionData)`, `useState(sourceType)`, `useState(editingName)`
- ConditionGroup.jsx: `useState(groupData)`, `useState(sourceType)`, `useState(editingName)`
- Duplicate logic for name editing, source type tracking

**Recommended Solution**: **Custom Hook for Condition State**
```javascript
// /hooks/useConditionState.js
export function useConditionState(value, onChange, config) {
  const [data, setData] = useState(normalizeValue(value));
  const [sourceType, setSourceType] = useState(determineSourceType(data));
  const [editingName, setEditingName] = useState(false);
  
  const handleChange = (updates) => {
    const updated = { ...data, ...updates };
    setData(updated);
    onChange(updated);
  };
  
  const handleNameChange = (newName) => {
    handleChange({ name: newName });
    setEditingName(false);
  };
  
  return {
    data,
    sourceType,
    editingName,
    setEditingName,
    handleChange,
    handleNameChange,
    setSourceType
  };
}
```

#### 4. **Naming Logic Scattered**
**Current**: Naming decisions made in multiple places:
- Condition.jsx: `handleSourceChange` generates child names when converting to group
- ConditionGroup.jsx: `addCondition` and `addConditionGroup` generate names
- Case.jsx: `addWhenClause` generates names
- No centralized validation of naming rules

**Recommended Solution**: **Naming Manager Service**
```javascript
// /utils/namingManager.js
export class NamingManager {
  constructor(rootCondition) {
    this.root = rootCondition;
  }
  
  // Get name for new condition at a given path
  getNameForNewCondition(parentPath = '') {
    const siblings = this.getSiblingsAtPath(parentPath);
    const parentNumber = this.getParentNumber(parentPath);
    const nextNum = getNextNumber(siblings, parentNumber);
    return generateDefaultName('condition', parentNumber, nextNum);
  }
  
  // Get name for new group at a given path
  getNameForNewGroup(parentPath = '') {
    const siblings = this.getSiblingsAtPath(parentPath);
    const parentNumber = this.getParentNumber(parentPath);
    const nextNum = getNextNumber(siblings, parentNumber);
    return generateDefaultName('conditionGroup', parentNumber, nextNum);
  }
  
  // Update all names in tree
  renumberTree() {
    return assignNamesToTree(this.root);
  }
  
  // Helper methods...
}
```

#### 5. **Testing Challenges**
**Current Issues**:
- UI components tightly coupled with logic
- Hard to test naming logic without rendering full component tree
- Mock data creation is verbose and error-prone

**Recommended Solutions**:
1. **Separate Logic from UI** - Extract business logic into hooks/services
2. **Test Utilities** - Create helpers for generating test fixtures
3. **Component Testing** - Use React Testing Library with proper mocking

```javascript
// /tests/fixtures/conditionFixtures.js
export const fixtures = {
  simpleCondition: (overrides = {}) => ({
    type: 'condition',
    returnType: 'boolean',
    name: 'Condition',
    left: { type: 'field', returnType: 'number', field: 'TABLE1.NUMBER_FIELD_01' },
    operator: 'equal',
    right: { type: 'value', returnType: 'number', value: 0 },
    ...overrides
  }),
  
  conditionGroup: (conditions = [], overrides = {}) => ({
    type: 'conditionGroup',
    returnType: 'boolean',
    name: 'Condition Group',
    conjunction: 'AND',
    not: false,
    conditions: conditions.length > 0 ? conditions : [
      fixtures.simpleCondition({ name: 'Condition 1' }),
      fixtures.simpleCondition({ name: 'Condition 2' })
    ],
    ...overrides
  })
};
```

#### 6. **Config Dependency Everywhere**
**Problem**: Almost every function needs `config` parameter
- Makes testing harder (need full config object)
- Unclear what parts of config are actually needed
- Config structure not well-documented

**Recommended Solution**: **Config Facade Pattern**
```javascript
// /utils/configFacade.js
export class ConfigFacade {
  constructor(config) {
    this.config = config;
  }
  
  getDefaultOperatorForType(returnType) {
    return this.config?.types?.[returnType]?.defaultConditionOperator || 'equal';
  }
  
  getDefaultField() {
    return this.config?.defaultField || 'TABLE1.NUMBER_FIELD_01';
  }
  
  getValidOperatorsForType(returnType) {
    return this.config?.types?.[returnType]?.validConditionOperators || [];
  }
  
  // etc.
}
```

---

## Recommended Implementation Approach

### Phase 1: Refactoring & Cleanup (Do First)
**Goal**: Make codebase easier to work with before adding naming

1. **Create Structure Factories** (`/utils/structureFactories.js`)
   - `createDefaultCondition(config, name)`
   - `createDefaultConditionGroup(config, name, children)`
   - `createDefaultExpression(type, returnType, value)`
   - Replace all inline object creation

2. **Create Test Fixtures** (`/tests/fixtures/`)
   - `conditionFixtures.js` - Pre-built condition structures
   - `configFixtures.js` - Mock config objects
   - `expressionFixtures.js` - Common expression patterns

3. **Extract Custom Hooks**
   - `useConditionState.js` - State management for Condition/ConditionGroup
   - `useNameEditing.js` - Name editing UI logic
   - `useExpansionState.js` - Already exists, good example

4. **Create Config Facade**
   - Wrap config object with clean API
   - Makes it clear what config properties are used where

**Benefits**:
- Easier to add naming logic
- Better test coverage
- Reduced code duplication
- Clear separation of concerns

**Estimated Effort**: 4-6 hours
**Risk**: Low (mostly extracting existing code)

---

### Phase 2: Naming Integration (After Refactoring)

#### Option A: Full Context-Based Solution (Recommended)
**Approach**: Create NamingContext provider at RuleBuilder level

**Steps**:
1. Create `NamingContext.jsx` with provider
2. Create `useNaming()` hook
3. Update RuleBuilder to wrap content in NamingProvider
4. Update components to use `useNaming()` instead of props
5. Remove `parentNumber`, `position`, `siblings` props

**Pros**:
- Clean, maintainable architecture
- Easy to test
- No prop drilling
- Follows React best practices

**Cons**:
- Larger initial refactor
- More files to create

**Estimated Effort**: 6-8 hours
**Risk**: Medium (architectural change)

#### Option B: Minimal Props-Based Solution
**Approach**: Keep current architecture, add naming props

**Steps**:
1. Add naming props to Condition/ConditionGroup
2. Update parent components to calculate and pass props
3. Update all creation methods to use naming utilities
4. Thread props through entire tree

**Pros**:
- Matches current architecture
- Smaller change

**Cons**:
- Props explosion
- Harder to maintain
- Complex prop threading
- Harder to test

**Estimated Effort**: 8-10 hours (complexity from prop threading)
**Risk**: Medium-High (easy to miss places, hard to debug)

---

## Detailed Implementation Steps

### Recommended: Option A (Context-Based)

#### Step 1: Create Naming Context (1 hour)
```javascript
// /contexts/NamingContext.jsx
import React, { createContext, useContext, useMemo } from 'react';
import {
  generateDefaultName,
  updateNameOnTypeChange,
  getNextNumber,
  generateResultName,
  generateElseName,
  assignNamesToTree
} from '../utils/conditionNaming';

const NamingContext = createContext(null);

export function NamingProvider({ children, conditionTree }) {
  const namingService = useMemo(() => ({
    // Get name for new item
    getNameForNew(type, parentPath = '', siblings = []) {
      const parentNumber = extractParentNumber(parentPath);
      const nextNum = getNextNumber(siblings, parentNumber);
      return generateDefaultName(type, parentNumber, nextNum);
    },
    
    // Update name on type change
    updateName(currentName, oldType, newType, parentPath = '', position = null, ruleId = null) {
      const parentNumber = extractParentNumber(parentPath);
      return updateNameOnTypeChange(currentName, oldType, newType, parentNumber, position, ruleId);
    },
    
    // Get result name for WHEN clause
    getResultName(whenClauseIndex) {
      return generateResultName(whenClauseIndex);
    },
    
    // Get ELSE name
    getElseName() {
      return generateElseName();
    },
    
    // Renumber entire tree
    renumberTree(tree) {
      return assignNamesToTree(tree, '', null);
    }
  }), [conditionTree]);
  
  return (
    <NamingContext.Provider value={namingService}>
      {children}
    </NamingContext.Provider>
  );
}

export function useNaming() {
  const context = useContext(NamingContext);
  if (!context) {
    throw new Error('useNaming must be used within NamingProvider');
  }
  return context;
}

// Helper to extract parent number from expansion path
function extractParentNumber(path) {
  // Parse paths like 'condition-0-group-1-condition-2' 
  // to get numbering context
  // Implementation depends on your path format
  return '';
}
```

#### Step 2: Update Structure Factories (1 hour)
```javascript
// /utils/structureFactories.js
import { createDirectExpression } from '../components/RuleBuilder/Expression';

export function createDefaultCondition(config, name) {
  const defaultType = 'number';
  const defaultField = config?.defaultField || 'TABLE1.NUMBER_FIELD_01';
  const defaultOperator = config?.types?.[defaultType]?.defaultConditionOperator || 'equal';
  
  return {
    type: 'condition',
    returnType: 'boolean',
    name,
    left: createDirectExpression('field', defaultType, defaultField),
    operator: defaultOperator,
    right: createDirectExpression('value', defaultType, 0)
  };
}

export function createDefaultConditionGroup(config, name, children = null) {
  const defaultChildren = children || [
    createDefaultCondition(config, 'Condition 1'),
    createDefaultCondition(config, 'Condition 2')
  ];
  
  return {
    type: 'conditionGroup',
    returnType: 'boolean',
    name,
    conjunction: 'AND',
    not: false,
    conditions: defaultChildren
  };
}

export function createDefaultRuleRef(name) {
  return {
    type: 'condition',
    returnType: 'boolean',
    name,
    ruleRef: {
      id: null,
      uuid: null,
      version: 1,
      returnType: 'boolean'
    }
  };
}
```

#### Step 3: Update RuleBuilder to Provide Context (0.5 hours)
```javascript
// In RuleBuilder.jsx
import { NamingProvider } from '../../contexts/NamingContext';

// Inside RuleBuilder component:
return (
  <NamingProvider conditionTree={definition}>
    <RuleBuilderUI
      definition={definition}
      // ... other props
    />
  </NamingProvider>
);
```

#### Step 4: Update Condition.jsx to Use Context (1.5 hours)
```javascript
// Remove props: parentNumber, position, siblings
// Add useNaming hook
const naming = useNaming();

// In handleSourceChange:
if (newSourceType === 'conditionGroup') {
  const groupName = naming.updateName(
    conditionData.name,
    oldSourceType,
    'conditionGroup',
    expansionPath,
    null // position calculated from path
  );
  
  // Get names for children
  const child1Name = naming.getNameForNew('condition', expansionPath, []);
  const child2Name = naming.getNameForNew('condition', expansionPath, [{ name: child1Name }]);
  
  // ... rest of logic
}
```

#### Step 5: Update ConditionGroup.jsx (2 hours)
```javascript
// In addCondition:
const naming = useNaming();
const conditions = groupData.conditions || [];

const newName = naming.getNameForNew('condition', expansionPath, conditions);
const newCondition = createDefaultCondition(config, newName);

handleChange({ conditions: [...conditions, newCondition] });

// In addConditionGroup:
const newName = naming.getNameForNew('conditionGroup', expansionPath, conditions);
const newGroup = createDefaultConditionGroup(config, newName);

handleChange({ conditions: [...conditions, newGroup] });
```

#### Step 6: Update Case.jsx (1.5 hours)
```javascript
// In addWhenClause:
const naming = useNaming();
const whenClauses = caseData.whenClauses || [];

const conditionName = naming.getNameForNew('condition', 'case', whenClauses);
const resultName = naming.getResultName(whenClauses.length);

const newWhenClause = {
  when: createDefaultCondition(config, conditionName),
  then: createDefaultExpression('value', caseData.returnType, '', resultName)
};

// In ELSE clause initialization:
const elseName = naming.getElseName(); // "Default"
```

#### Step 7: Update useRuleBuilder Hook (1 hour)
```javascript
// In initializeDefinition:
const naming = useNaming(); // or pass as parameter

if (structure === 'condition') {
  definition = createDefaultCondition(config, 'Condition');
} else if (structure === 'case') {
  const when1Name = naming.getNameForNew('condition', '', []);
  const result1Name = naming.getResultName(0);
  const elseName = naming.getElseName();
  
  definition = {
    whenClauses: [{
      when: createDefaultCondition(config, when1Name),
      then: createDefaultExpression('value', returnType, '', result1Name)
    }],
    else: createDefaultExpression('value', returnType, '', elseName)
  };
}
```

#### Step 8: Testing & Validation (2 hours)
1. Run all existing tests - should still pass
2. Manual testing of CSV scenarios
3. Edge case testing (deep nesting, deletions, reordering)
4. Fix any issues found

---

## Alternative: Minimal Changes Approach

If you want to minimize changes and just "make it work":

### Quick Integration Steps (No Refactoring)

1. **Add Helper Function to Calculate Context** (0.5 hours)
```javascript
// Add to Condition.jsx
function getNameContext(value, depth, expansionPath) {
  // Extract position from expansion path
  const pathMatch = expansionPath.match(/-(\d+)$/);
  const position = pathMatch ? parseInt(pathMatch[1], 10) + 1 : null;
  
  // Calculate parent number from depth and position
  const parentNumber = depth === 0 ? '' : calculateParentNumber(expansionPath);
  
  return { position, parentNumber };
}
```

2. **Update handleSourceChange Inline** (already done)

3. **Update addCondition/addGroup in ConditionGroup** (1 hour)
```javascript
// Just use the utilities directly without props
const addCondition = () => {
  const conditions = groupData.conditions || [];
  const parentNumber = calculateParentNumber(expansionPath, depth);
  const nextNum = getNextNumber(conditions, parentNumber);
  const newName = generateDefaultName('condition', parentNumber, nextNum);
  
  const newCondition = createDefaultCondition(config, newName);
  // ... rest
};
```

4. **Update Case.jsx addWhenClause** (0.5 hours)
```javascript
const addWhenClause = () => {
  const whenClauses = caseData.whenClauses || [];
  const conditionNum = whenClauses.length + 1;
  const conditionName = `Condition ${conditionNum}`;
  const resultName = generateResultName(whenClauses.length);
  // ... rest
};
```

**Total Effort**: 2-3 hours
**Quality**: Lower (technical debt remains)
**Maintainability**: Poor

---

## Recommendation

**Go with Context-Based Approach (Option A)**

**Why**:
1. Only ~2-3 hours more than minimal approach
2. Much better code quality
3. Easier to test and maintain
4. Follows React best practices
5. Sets foundation for future enhancements
6. Makes codebase more professional

**Implementation Order**:
1. Structure Factories (low risk, high value)
2. Test Fixtures (makes testing easier)
3. Naming Context (core infrastructure)
4. Component Updates (straightforward once context exists)

**Timeline**:
- Day 1 (4 hours): Factories, fixtures, context
- Day 2 (4 hours): Component integration, testing
- **Total: ~8 hours for clean, maintainable solution**

---

## Testing Strategy

### Unit Tests (Already Done ‚úì)
- 35 tests for naming utilities
- All passing

### Integration Tests (Need to Add)
1. **Test naming through UI interactions**
   - Create condition ‚Üí check name
   - Convert to group ‚Üí check names update
   - Add condition to group ‚Üí check sequential numbering
   - User rename ‚Üí check preservation

2. **Test Case expression naming**
   - Add WHEN clauses ‚Üí check Condition 1, 2, 3
   - Check THEN ‚Üí check Result 1, 2, 3
   - Check ELSE ‚Üí check "Default"

3. **Test rule reference naming**
   - Select rule ‚Üí check name becomes rule ID
   - Clear rule ‚Üí check name reverts

### Example Integration Test
```javascript
describe('Naming Integration', () => {
  it('maintains proper names when converting condition to group', () => {
    const { getByText, getByRole } = render(
      <RuleBuilder initialStructure="condition" />
    );
    
    // Initial state should be "Condition"
    expect(getByText('Condition')).toBeInTheDocument();
    
    // Click "Add Condition" button
    fireEvent.click(getByRole('button', { name: /add condition/i }));
    
    // Should now be "Condition Group" with "Condition 1" and "Condition 2"
    expect(getByText('Condition Group')).toBeInTheDocument();
    expect(getByText('Condition 1')).toBeInTheDocument();
    expect(getByText('Condition 2')).toBeInTheDocument();
  });
});
```

---

## Risk Assessment

### Low Risk Items ‚úÖ
- Structure factories (pure functions)
- Test fixtures (test-only code)
- Naming utilities (already tested)

### Medium Risk Items ‚ö†Ô∏è
- Context implementation (new pattern)
- Component refactoring (could break UI)
- Prop removal (need to update all call sites)

### High Risk Items üî¥
- None (if we follow phased approach)

### Mitigation Strategies
1. **Small PRs** - One phase at a time
2. **Test Coverage** - Write tests before changing components
3. **Manual Testing** - Follow CSV scenarios after each change
4. **Rollback Plan** - Git branches for each phase

---

## Open Questions

1. **Name Persistence**: When deleting items, should remaining items keep their numbers or renumber?
   - **Recommend**: Keep numbers (stability)
   - User deletes "Condition 2", "Condition 3" stays as "Condition 3"

2. **Manual Renaming UI**: Should there be visual indicator for custom vs auto-generated names?
   - Could show icon next to custom names
   - Could reset button to revert to auto-generated

3. **Undo/Redo**: Should naming changes be tracked in history?
   - If yes, need to integrate with existing undo system
   - If no, simpler implementation

4. **Deep Nesting**: What's the max depth we support?
   - Current CSV shows 4 levels (2.1.1.2)
   - Should we have a limit?

5. **Import/Migration**: What happens to existing rules without proper names?
   - Run `assignNamesToTree()` on load?
   - Show warning?
   - Auto-fix silently?

---

## Success Criteria

### Must Have ‚úÖ
- [ ] All CSV scenarios work correctly
- [ ] All 197 existing tests still pass
- [ ] New integration tests pass
- [ ] No console errors
- [ ] Names persist across saves/loads

### Should Have üéØ
- [ ] Code is maintainable and well-documented
- [ ] Components are easier to test
- [ ] No prop drilling
- [ ] Clear separation of concerns

### Nice to Have üåü
- [ ] Visual indicators for custom names
- [ ] Name validation/warnings
- [ ] Bulk renaming utilities
- [ ] Name templates/patterns

---

## Next Steps

**Immediate Actions**:
1. Review this plan with team
2. Decide: Context-based vs Minimal approach
3. Answer open questions
4. Create feature branch
5. Start with Phase 1 (refactoring)

**Questions for You**:
1. Do you want to proceed with Context-based (recommended) or Minimal approach?
2. Should we tackle refactoring first, or go straight to minimal naming integration?
3. Any specific concerns about the architecture changes?
4. What's your timeline/urgency?
